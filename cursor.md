项目规范文档：基于李群特征与 ArcFace 的机械故障诊断系统1. 项目背景与目标本项目旨在构建一个高精度的机械故障智能诊断系统。输入数据：由上游李群（Lie Group）算法处理生成的双通道 1D 时序信号。Channel 0: 能量曲线 (Energy Curve) - 反映信号冲击与瞬时功率。Channel 1: 密度曲线 (Density Curve) - 反映流形空间的熵或混乱度。核心算法：利用 1D-CNN 作为特征提取器，结合 ArcFace (Additive Angular Margin Loss) 进行度量学习（Metric Learning）。目标：在特征空间将同类故障极致压缩，异类故障拉开距离，以实现高精度的故障分类和未知故障检测（Open-set Recognition）。最终模型将部署于边缘计算设备。2. 技术栈语言：Python 3.8+框架：PyTorch (最新稳定版)依赖库：NumPy, Scikit-learn (用于 t-SNE 和评估), Matplotlib/Seaborn (用于可视化)3. 数据规范 (Data Specification)假设输入数据存储为 .npy 格式（或由代码生成的模拟数据进行测试）。样本形状：(N, 2, L)N: 样本数量2: 通道数 (Energy, Density)L: 序列长度 (例如 1024)预处理要求：必须进行 Standard Normalization (Z-Score)：即减去均值，除以标准差。注意：归一化应在 Channel 维度独立进行（能量归一化能量的，密度归一化密度的）。4. 模块详细设计 (Module Design)4.1 数据加载 (data_loader.py)定义 LieGroupDataset(Dataset) 类。实现 __getitem__：读取数据。执行 (x - mean) / std 标准化。返回 tensor(dtype=float32) 和 label(long)。提供 get_dataloaders(batch_size, split_ratio) 函数。4.2 模型骨干 (model.py)架构：修改版的 ResNet-18 1D。输入：(Batch, 2, Length)。修改点：将所有 nn.Conv2d 替换为 nn.Conv1d。将所有 nn.BatchNorm2d 替换为 nn.BatchNorm1d。去掉最后的全连接分类层。输出：输出层结构：Flatten -> Linear(in_features, 512) -> BatchNorm1d(512)。重要：输出的是 512 维的特征向量 (Embedding)，不是分类概率。4.3 损失函数 (loss.py) - 核心实现 ArcFace Loss (ArcMarginProduct)。数学逻辑：输入：特征向量 $emb$ (Batch, 512), 标签 $label$。权重：$W$ (Class_Num, 512)。L2 归一化：对 $emb$ 和 $W$ 都必须进行 L2 归一化。计算 Cosine：$cosine = F.linear(L2\_emb, L2\_W)$。添加 Margin：对对应 Label 的 $cosine$ 值进行 $\arccos$ 变换，加上 $m=0.5$，再取 $\cos$。缩放：乘以 $s=30$（或其他超参）。返回 Logits，供 CrossEntropyLoss 使用。4.4 训练引擎 (train.py)初始化 Backbone 和 ArcFace Head。优化器：同时优化这两个模块的参数。训练循环：Forward: features = backbone(imgs) -> logits = arcface(features, labels)。Loss: CrossEntropy(logits, labels)。验证循环：仅计算 Accuracy。保存策略：分别保存 backbone.pth (用于推理) 和 arcface_head.pth (仅用于恢复训练)。4.5 边缘推理与评估 (inference.py)场景：模拟边缘端部署，不加载 ArcFace Head。逻辑：加载训练好的 Backbone。加载（或预计算）故障中心向量 (Centroids)。对输入信号提取特征 -> L2 归一化。计算特征与所有中心向量的 Cosine Similarity。判定：若最大相似度 > 阈值 (如 0.4)：输出对应类别。若最大相似度 < 阈值：输出 "Unknown/Anomaly"。可视化：使用 t-SNE 对测试集的 512维 Embedding 进行降维展示，验证聚类效果。